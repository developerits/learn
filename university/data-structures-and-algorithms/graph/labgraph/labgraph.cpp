// labgraph.cpp : Этот файл содержит функцию "main". Здесь начинается и заканчивается выполнение программы.
//

#include <iostream>
using namespace std;

// Рамеры матрицы.
const int n = 6;
int i, j;

//матрица смежности графа
int GM[n][n] =
{
{0, 1, 1, 0, 0, 1},
{1, 0, 0, 1, 0, 0},
{1, 0, 0, 0, 0, 1},
{0, 1, 0, 0, 1, 0},
{0, 0, 0, 1, 0, 1},
{1, 0, 1, 0, 1, 0}
};

//поиск в ширину. Есть очередь, но нет рекурсии
void BFS(bool* visited, int unit, int target)
{
	// Необходимые переменные.
	int* queue = new int[n];
	int* p = new int[n]; // Массив в котором по индексу целевой вершины, можно получить вершину из которой можно попасть в целевую.
	int count, head; // Счетчик количества вершин в очереди, индекс последней вершины в очереди queue.

	// Инициализация переменных.
	for (i = 0; i < n; i++) p[i] = queue[i] = 0;
	count = 0; head = 0;

	// Помещение начальной вершины в пустую очередь и пометка этой вершины, как посещенной.
	queue[count++] = unit;
	visited[unit] = true;
	p[unit] = -1;

	// Поиск в ширину.
	while (head < count)
	{
		// Берется строка в матрице смежности.
		unit = queue[head++];
		cout << unit + 1 << " ";
		// Итерация по столбцам строки матрицы смежности.
		for (i = 0; i < n; i++) 
		{
			// Если есть путь к вершине и она еще не посещена.
			if (GM[unit][i] && !visited[i])
			{
				// Вершина добавляется в очередь.
				queue[count++] = i;
				// Вершина помечается как посещенная.
				visited[i] = true;
				// Сохраняется предыдущая вершина из которой мы попали в текущую.
				p[i] = unit;
			}
		}
	}

	// Если вершина не посещена, то пути нет.
	if (!visited[target]) cout << "Нет пути." << endl;
	else 
	{
		int* path = new int[n];
		// Восстанавливаются строки для целевой вершины.
		count = 0;
		int i = target; // Целевая вершина.
		while (i != -1) 
		{
			path[count++] = i; // Предыдущая вершина кладется в массив.
			i = p[i]; // Берется предыдущая вершина, из которой мы можем попасть в вершину i.
		}

		cout << "Кратчайший путь: ";
		for (i = n-1; i >= 0; i--)if (path[i] + 1 > 0) cout << path[i] + 1 << " ";
		cout << endl;
	}

	delete[]queue;
}

int main()
{
	// Установка русского языка.
	setlocale(LC_ALL, "Rus"); 

	// Распечатка матрицы смежности графа.
	cout << "Матрица смежности графа: " << endl;
	bool* visited = new bool[n];
	for (i = 0; i < n; i++)
	{
		visited[i] = false;
		for (j = 0; j < n; j++) cout << " " << GM[i][j];
		cout << endl;
	}

	// Ввод стартовой вершины и вершины, путь до которой надо найти.
	int start, to;
	cout << "Стартовая вершина >> "; cin >> start;
	cout << "Вершина до которой нужно найти кратчайший путь >> "; cin >> to;

	cout << "Порядок обхода: ";
	BFS(visited, start - 1, to - 1);

	delete[]visited;
}

// Запуск программы: CTRL+F5 или меню "Отладка" > "Запуск без отладки"
// Отладка программы: F5 или меню "Отладка" > "Запустить отладку"

// Советы по началу работы 
//   1. В окне обозревателя решений можно добавлять файлы и управлять ими.
//   2. В окне Team Explorer можно подключиться к системе управления версиями.
//   3. В окне "Выходные данные" можно просматривать выходные данные сборки и другие сообщения.
//   4. В окне "Список ошибок" можно просматривать ошибки.
//   5. Последовательно выберите пункты меню "Проект" > "Добавить новый элемент", чтобы создать файлы кода, или "Проект" > "Добавить существующий элемент", чтобы добавить в проект существующие файлы кода.
//   6. Чтобы снова открыть этот проект позже, выберите пункты меню "Файл" > "Открыть" > "Проект" и выберите SLN-файл.
